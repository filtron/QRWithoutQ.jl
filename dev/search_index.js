var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QRWithoutQ","category":"page"},{"location":"#QRWithoutQ","page":"Home","title":"QRWithoutQ","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QRWithoutQ.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QRWithoutQ]","category":"page"},{"location":"#QRWithoutQ._downcale_beta-Tuple{Any, Any, Any}","page":"Home","title":"QRWithoutQ._downcale_beta","text":"_downcale_beta(β, knt, sfmin)\n\nUndo the rescaling of β.\n\n\n\n\n\n","category":"method"},{"location":"#QRWithoutQ._upscale_input!-Union{Tuple{T}, Tuple{AbstractVector{T}, Vararg{Any, 4}}} where T","page":"Home","title":"QRWithoutQ._upscale_input!","text":"_upscale_input!(xtail::AbstractMatrix{T}, α, β, sfmin, rsfmin) where {T}\n\nRescale the input to clarfg! if it is too small.\n\n\n\n\n\n","category":"method"},{"location":"#QRWithoutQ.apply_reflector!-Tuple{AbstractVector, Any, AbstractVecOrMat}","page":"Home","title":"QRWithoutQ.apply_reflector!","text":"apply_reflector!(x::AbstractVector, τ, A::AbstractVecOrMat)\n\n\n\n\n\n","category":"method"},{"location":"#QRWithoutQ.clarfg!-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Home","title":"QRWithoutQ.clarfg!","text":"clarfg!(x::AbstractVector{T}) where {T}\n\nIntended to be a reasonably faithful implementation of clarg from LAPACK.\n\n\n\n\n\n","category":"method"},{"location":"#QRWithoutQ.qr_unblocked!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T","page":"Home","title":"QRWithoutQ.qr_unblocked!","text":"qr_unblocked!(A::AbstractMatrix{T}, τ) where {T}\n\nComputes the unblocked QR decomposition of A, in-place. The vector τ is used for storing the scalar coefficients for the Householder reflectors.\n\n\n\n\n\n","category":"method"},{"location":"#QRWithoutQ.qrwoq!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"QRWithoutQ.qrwoq!","text":"qrwoq!(A::AbstractMatrix{T}, A::AbstractMatrix{T}) where {T}\n\nComputes the upper triangular qr factor of A in-place and returns a view into A giving the upper triangular factor. The scalar factor the in\n\n\n\n\n\n","category":"method"},{"location":"#QRWithoutQ.qrwoq_unblocked!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"QRWithoutQ.qrwoq_unblocked!","text":"qrwoq_unblocked!(A::AbstractMatrix{T}) where {T}\n\nComputes the R factor in the unblocked QR decomposition, in-place. R is returned as a view of A and all Householder vectors are destroyed.\n\n\n\n\n\n","category":"method"},{"location":"#QRWithoutQ.safemin-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"QRWithoutQ.safemin","text":"safemin(::Type{T})\n\nSmallest element of type T for which it is safe to divide by. Intended to be an implementation of LAPACKs slamch( 'S' ) / slamch( 'E' ) but I could be wrong...\n\n\n\n\n\n","category":"method"}]
}
